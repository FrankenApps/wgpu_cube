<!DOCTYPE html>

<head>
    <title>Efficient cube</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link rel="icon" type="image/png" href="/favicon.png">
</head>

<style>
    html {
        height: 100%;
    }
</style>

<body style="background-color: white; margin: 0; overflow: hidden; width: 100%; height: 100%;">
    <canvas id="wgc_1" style="width: 100%; height: 100%; display: block; margin: 0px;"></canvas>

    <script type="module">
        import init, { WebGLRenderer } from './pkg/wgpu_shape_renderer.js';

        let isDragRotate = false;
        const mouse_speed = 0.025;
        const zoom_speed = 0.01;

        let previousDistance = undefined;
        let touchstartX = undefined;
        let touchstartY = undefined;

        async function run() {
            await init();

            const canvas = document.querySelector("#wgc_1");
            let width = canvas.clientWidth;
            let height = canvas.clientHeight;
            canvas.width = width;
            canvas.height = height;

            let state = new WebGLRenderer('wgc_1', width, height);
            state.update();
            state.render();

            // Append our event listeners.
            canvas.addEventListener('mousedown', e => {
                isDragRotate = true;
            });

            canvas.addEventListener('mousemove', e => {
                if (isDragRotate === true) {
                    state.add_yaw(-e.movementX * mouse_speed);
                    state.add_pitch(e.movementY * mouse_speed);
                    state.update();
                    state.render();
                }
            });

            canvas.addEventListener('mouseup', e => {
                if (isDragRotate === true) {
                    isDragRotate = false;
                }
            });

            canvas.addEventListener('wheel', e => {
                e.preventDefault();

                state.add_distance(e.deltaY * mouse_speed);
                state.update();
                state.render();
            });

            canvas.addEventListener('touchstart', e => {
                if (e.touches.length === 1) {
                    touchstartX = e.touches[0].pageX;
                    touchstartY = e.touches[0].pageY;
                }
            });

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    state.add_yaw(-(e.touches[0].pageX - touchstartX) * mouse_speed);
                    state.add_pitch((e.touches[0].pageY - touchstartY) * mouse_speed);
                    state.update();
                    state.render();

                    touchstartX = e.touches[0].pageX;
                    touchstartY = e.touches[0].pageY;
                }
                else if (e.touches.length === 2) {
                    let newDistance = Math.hypot((e.touches[0].pageX - e.touches[1].pageX),
                        (e.touches[0].pageY - e.touches[1].pageY));
                    if (previousDistance === undefined) {
                        previousDistance = newDistance;
                    }
                    let delta = newDistance - previousDistance;
                    if (Math.abs(delta) > 2) {
                        state.add_distance(-delta * zoom_speed);
                        state.update();
                        state.render();
                    }
                }
            });

            canvas.addEventListener('touchend', () => {
                previousDistance = undefined;
            });

            /* window.addEventListener('resize', () => {
                width = canvas.clientWidth;
                height = canvas.clientHeight;
                canvas.width = width;
                canvas.height = height;
                // Somehow this makes the WASM backend fail silently.
                state.resize(width, height);
                state.update();
                state.render();
            }); */

            document.addEventListener('keydown', e => {
                if (e.keyCode === 32) {
                    width = canvas.clientWidth;
                    height = canvas.clientHeight;
                    canvas.width = width;
                    canvas.height = height;
                    // Somehow this makes the WASM backend fail silently.
                    state.resize(width, height);
                    state.update();
                    state.render();
                }
            });
        }

        run();
    </script>
</body>

</html>